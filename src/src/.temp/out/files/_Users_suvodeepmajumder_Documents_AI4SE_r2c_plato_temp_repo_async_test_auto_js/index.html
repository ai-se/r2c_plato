<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - /Users/suvodeepmajumder/Documents/AI4SE/r2c_plato/temp_repo/async/test/auto.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>/Users/suvodeepmajumder/Documents/AI4SE/r2c_plato/temp_repo/async/test/auto.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">79.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">492</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">64.81</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var async = require(&#039;../lib&#039;);
var {expect} = require(&#039;chai&#039;);
var _ = require(&#039;lodash&#039;);

describe(&#039;auto&#039;, () =&gt; {

    it(&#039;basics&#039;, (done) =&gt; {
        var callOrder = [];
        async.auto({
            task1: [&#039;task2&#039;, function(results, callback){
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task1&#039;);
                    callback();
                }, 25);
            }],
            task2(callback){
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task2&#039;);
                    callback();
                }, 50);
            },
            task3: [&#039;task2&#039;, function(results, callback){
                callOrder.push(&#039;task3&#039;);
                callback();
            }],
            task4: [&#039;task1&#039;, &#039;task2&#039;, function(results, callback){
                callOrder.push(&#039;task4&#039;);
                callback();
            }],
            task5: [&#039;task2&#039;, function(results, callback){
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task5&#039;);
                    callback();
                }, 0);
            }],
            task6: [&#039;task2&#039;, function(results, callback){
                callOrder.push(&#039;task6&#039;);
                callback();
            }]
        },
        (err) =&gt; {
            expect(err).to.equal(null);
            expect(callOrder).to.eql([&#039;task2&#039;,&#039;task3&#039;,&#039;task6&#039;,&#039;task5&#039;,&#039;task1&#039;,&#039;task4&#039;]);
            done();
        });
    });

    it(&#039;auto concurrency&#039;, (done) =&gt; {
        var concurrency = 2;
        var runningTasks = [];

        function makeCallback(taskName) {
            return function(...args/*..., callback*/) {
                var callback = _.last(args);
                runningTasks.push(taskName);
                setTimeout(() =&gt; {
                    // Each task returns the array of running tasks as results.
                    var result = runningTasks.slice(0);
                    runningTasks.splice(runningTasks.indexOf(taskName), 1);
                    callback(null, result);
                });
            };
        }

        async.auto({
            task1: [&#039;task2&#039;, makeCallback(&#039;task1&#039;)],
            task2: makeCallback(&#039;task2&#039;),
            task3: [&#039;task2&#039;, makeCallback(&#039;task3&#039;)],
            task4: [&#039;task1&#039;, &#039;task2&#039;, makeCallback(&#039;task4&#039;)],
            task5: [&#039;task2&#039;, makeCallback(&#039;task5&#039;)],
            task6: [&#039;task2&#039;, makeCallback(&#039;task6&#039;)]
        }, concurrency, (err, results) =&gt; {
            _.each(results, (result) =&gt; {
                expect(result.length).to.be.below(concurrency + 1);
            });
            done();
        });
    });

    it(&#039;auto petrify&#039;, (done) =&gt; {
        var callOrder = [];
        async.auto({
            task1: [&#039;task2&#039;, function (results, callback) {
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task1&#039;);
                    callback();
                }, 100);
            }],
            task2 (callback) {
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task2&#039;);
                    callback();
                }, 200);
            },
            task3: [&#039;task2&#039;, function (results, callback) {
                callOrder.push(&#039;task3&#039;);
                callback();
            }],
            task4: [&#039;task1&#039;, &#039;task2&#039;, function (results, callback) {
                callOrder.push(&#039;task4&#039;);
                callback();
            }]
        },
        (err) =&gt; {
            if (err) throw err;
            expect(callOrder).to.eql([&#039;task2&#039;, &#039;task3&#039;, &#039;task1&#039;, &#039;task4&#039;]);
            done();
        });
    });

    it(&#039;auto results&#039;, (done) =&gt; {
        var callOrder = [];
        async.auto({
            task1: [&#039;task2&#039;, function(results, callback){
                expect(results.task2).to.eql(&#039;task2&#039;);
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task1&#039;);
                    callback(null, &#039;task1a&#039;, &#039;task1b&#039;);
                }, 25);
            }],
            task2(callback){
                setTimeout(() =&gt; {
                    callOrder.push(&#039;task2&#039;);
                    callback(null, &#039;task2&#039;);
                }, 50);
            },
            task3: [&#039;task2&#039;, function(results, callback){
                expect(results.task2).to.eql(&#039;task2&#039;);
                callOrder.push(&#039;task3&#039;);
                callback(null);
            }],
            task4: [&#039;task1&#039;, &#039;task2&#039;, function(results, callback){
                expect(results.task1).to.eql([&#039;task1a&#039;,&#039;task1b&#039;]);
                expect(results.task2).to.eql(&#039;task2&#039;);
                callOrder.push(&#039;task4&#039;);
                callback(null, &#039;task4&#039;);
            }]
        },
        (err, results) =&gt; {
            expect(callOrder).to.eql([&#039;task2&#039;,&#039;task3&#039;,&#039;task1&#039;,&#039;task4&#039;]);
            expect(results).to.eql({task1: [&#039;task1a&#039;,&#039;task1b&#039;], task2: &#039;task2&#039;, task3: undefined, task4: &#039;task4&#039;});
            done();
        });
    });

    it(&#039;auto empty object&#039;, (done) =&gt; {
        async.auto({}, (err) =&gt; {
            expect(err).to.equal(null);
            done();
        });
    });

    it(&#039;auto error&#039;, (done) =&gt; {
        async.auto({
            task1(callback){
                callback(&#039;testerror&#039;);
            },
            task2: [&#039;task1&#039;, function(/*results, callback*/){
                throw new Error(&#039;task2 should not be called&#039;);
            }],
            task3(callback){
                callback(&#039;testerror2&#039;);
            }
        },
        (err) =&gt; {
            expect(err).to.equal(&#039;testerror&#039;);
        });
        setTimeout(done, 100);
    });

    it(&#039;auto canceled&#039;, (done) =&gt; {
        const call_order = []
        async.auto({
            task1(callback){
                call_order.push(1)
                callback(false);
            },
            task2: [&#039;task1&#039;, function(/*results, callback*/){
                call_order.push(2)
                throw new Error(&#039;task2 should not be called&#039;);
            }],
            task3(callback){
                call_order.push(3)
                callback(&#039;testerror2&#039;);
            }
        },
        () =&gt; {
            throw new Error(&#039;should not get here&#039;)
        });
        setTimeout(() =&gt; {
            expect(call_order).to.eql([1, 3])
            done()
        }, 10);
    });

    it(&#039;does not start other tasks when it has been canceled&#039;, (done) =&gt; {
        const call_order = []
        async.auto({
            task1(callback) {
                call_order.push(1);
                // defer calling task2, so task3 has time to stop execution
                async.setImmediate(callback);
            },
            task2: [&#039;task1&#039;, function( /*results, callback*/ ) {
                call_order.push(2);
                throw new Error(&#039;task2 should not be called&#039;);
            }],
            task3(callback) {
                call_order.push(3);
                callback(false);
            },
            task4: [&#039;task3&#039;, function( /*results, callback*/ ) {
                call_order.push(4);
                throw new Error(&#039;task4 should not be called&#039;);
            }]
        },
        () =&gt; {
            throw new Error(&#039;should not get here&#039;)
        });

        setTimeout(() =&gt; {
            expect(call_order).to.eql([1, 3])
            done()
        }, 25)
    });

    it(&#039;auto no callback&#039;, (done) =&gt; {
        async.auto({
            task1(callback){callback();},
            task2: [&#039;task1&#039;, function(results, callback){callback(); done();}]
        });
    });

    it(&#039;auto concurrency no callback&#039;, (done) =&gt; {
        async.auto({
            task1(callback){callback();},
            task2: [&#039;task1&#039;, function(results, callback){callback(); done();}]
        }, 1);
    });

    it(&#039;auto error should pass partial results&#039;, (done) =&gt; {
        async.auto({
            task1(callback){
                callback(null, &#039;result1&#039;);
            },
            task2: [&#039;task1&#039;, function(results, callback){
                callback(&#039;testerror&#039;, &#039;result2&#039;);
            }],
            task3: [&#039;task2&#039;, function(){
                throw new Error(&#039;task3 should not be called&#039;);
            }]
        },
        (err, results) =&gt; {
            expect(err).to.equal(&#039;testerror&#039;);
            expect(results.task1).to.equal(&#039;result1&#039;);
            expect(results.task2).to.equal(&#039;result2&#039;);
            done();
        });
    });

    // Issue 24 on github: https://github.com/caolan/async/issues#issue/24
    // Issue 76 on github: https://github.com/caolan/async/issues#issue/76
    it(&#039;auto removeListener has side effect on loop iteratee&#039;, (done) =&gt; {
        async.auto({
            task1: [&#039;task3&#039;, function(/*callback*/) { done(); }],
            task2: [&#039;task3&#039;, function(/*callback*/) { /* by design: DON&#039;T call callback */ }],
            task3(callback) { callback(); }
        });
    });

    // Issue 410 on github: https://github.com/caolan/async/issues/410
    it(&#039;auto calls callback multiple times&#039;, (done) =&gt; {
        var finalCallCount = 0;
        try {
            async.auto({
                task1(callback) { callback(null); },
                task2: [&#039;task1&#039;, function(results, callback) { callback(null); }]
            },

            // Error throwing final callback. This should only run once
            () =&gt; {
                finalCallCount++;
                var e = new Error(&#039;An error&#039;);
                e._test_error = true;
                throw e;
            });
        } catch (e) {
            if (!e._test_error) {
                throw e;
            }
        }
        setTimeout(() =&gt; {
            expect(finalCallCount).to.equal(1);
            done();
        }, 10);
    });


    it(&#039;auto calls callback multiple times with parallel functions&#039;, (done) =&gt; {
        async.auto({
            task1(callback) { setTimeout(callback,0,&#039;err&#039;); },
            task2(callback) { setTimeout(callback,0,&#039;err&#039;); }
        },
        // Error throwing final callback. This should only run once
        (err) =&gt; {
            expect(err).to.equal(&#039;err&#039;);
            done();
        });
    });


    // Issue 462 on github: https://github.com/caolan/async/issues/462
    it(&#039;auto modifying results causes final callback to run early&#039;, (done) =&gt; {
        async.auto({
            task1(callback){
                callback(null, &#039;task1&#039;);
            },
            task2: [&#039;task1&#039;, function(results, callback){
                results.inserted = true;
                setTimeout(() =&gt; {
                    callback(null, &#039;task2&#039;);
                }, 50);
            }],
            task3(callback){
                setTimeout(() =&gt; {
                    callback(null, &#039;task3&#039;);
                }, 100);
            }
        },
        (err, results) =&gt; {
            expect(results.inserted).to.equal(true);
            expect(results.task3).to.equal(&#039;task3&#039;);
            done();
        });
    });

    // Issue 263 on github: https://github.com/caolan/async/issues/263
    it(&#039;auto prevent dead-locks due to inexistant dependencies&#039;, (done) =&gt; {
        expect(() =&gt; {
            async.auto({
                task1: [&#039;noexist&#039;, function(results, callback){
                    callback(null, &#039;task1&#039;);
                }]
            });
        }).to.throw(/dependency `noexist`/);
        done();
    });

    // Issue 263 on github: https://github.com/caolan/async/issues/263
    it(&#039;auto prevent dead-locks due to cyclic dependencies&#039;, (done) =&gt; {
        expect(() =&gt; {
            async.auto({
                task1: [&#039;task2&#039;, function(results, callback){
                    callback(null, &#039;task1&#039;);
                }],
                task2: [&#039;task1&#039;, function(results, callback){
                    callback(null, &#039;task2&#039;);
                }]
            });
        }).to.throw();
        done();
    });

    // Issue 1092 on github: https://github.com/caolan/async/issues/1092
    it(&#039;extended cycle detection&#039;, (done) =&gt; {
        var task = function (name) {
            return function (results, callback) {
                callback(null, &#039;task &#039; + name);
            };
        };
        expect(() =&gt; {
            async.auto({
                a: [&#039;c&#039;, task(&#039;a&#039;)],
                b: [&#039;a&#039;, task(&#039;b&#039;)],
                c: [&#039;b&#039;, task(&#039;c&#039;)]
            });
        }).to.throw();
        done();
    });

    // Issue 988 on github: https://github.com/caolan/async/issues/988
    it(&#039;auto stops running tasks on error&#039;, (done) =&gt; {
        async.auto({
            task1 (callback) {
                callback(&#039;error&#039;);
            },
            task2 (/*callback*/) {
                throw new Error(&#039;test2 should not be called&#039;);
            }
        }, 1, (error) =&gt; {
            expect(error).to.equal(&#039;error&#039;);
            done();
        });
    });

    it(&#039;ignores results after an error&#039;, (done) =&gt; {
        async.auto({
            task1 (cb) {
                setTimeout(cb, 25, &#039;error&#039;);
            },
            task2 (cb) {
                setTimeout(cb, 30, null);
            },
            task3: [&#039;task2&#039;, function () {
                throw new Error(&quot;task should not have been called&quot;);
            }]
        }, (err) =&gt; {
            expect(err).to.equal(&#039;error&#039;);
            setTimeout(done, 25, null);
        });
    });

    it(&quot;does not allow calling callbacks twice&quot;, () =&gt; {
        expect(() =&gt; {
            async.auto({
                bad (cb) {
                    cb();
                    cb();
                }
            }, () =&gt; {});

        }).to.throw();
    });

    it(&#039;should handle array tasks with just a function&#039;, (done) =&gt; {
        async.auto({
            a: [function (cb) {
                cb(null, 1);
            }],
            b: [&quot;a&quot;, function (results, cb) {
                expect(results.a).to.equal(1);
                cb();
            }]
        }, done);
    });

    it(&quot;should avoid unncecessary deferrals&quot;, (done) =&gt; {
        var isSync = true;

        async.auto({
            step1 (cb) { cb(null, 1); },
            step2: [&quot;step1&quot;, function (results, cb) {
                cb();
            }]
        }, () =&gt; {
            expect(isSync).to.equal(true);
            done();
        });

        isSync = false;
    });

    // Issue 1358 on github: https://github.com/caolan/async/issues/1358
    it(&#039;should report errors when a task name is an array method&#039;, (done) =&gt; {
        async.auto({
            &#039;one&#039; (next) {
                next(&#039;Something bad happened here&#039;);
            },
            &#039;filter&#039; (next) {
                _.delay(() =&gt; {
                    next(null, &#039;All fine here though&#039;);
                }, 25);
            },
            &#039;finally&#039;: [&#039;one&#039;, &#039;filter&#039;, function (a, next) {
                _.defer(next);
            }]
        }, (err) =&gt; {
            expect(err).to.equal(&#039;Something bad happened here&#039;);
            _.delay(done, 30);
        });
    });

    it(&#039;should report errors when a task name is an obj prototype method&#039;, (done) =&gt; {
        async.auto({
            &#039;one&#039; (next) {
                next(&#039;Something bad happened here&#039;);
            },
            &#039;hasOwnProperty&#039; (next) {
                _.delay(() =&gt; {
                    next(null, &#039;All fine here though&#039;);
                }, 25);
            },
            &#039;finally&#039;: [&#039;one&#039;, &#039;hasOwnProperty&#039;, function (a, next) {
                _.defer(next);
            }]
        }, (err) =&gt; {
            expect(err).to.equal(&#039;Something bad happened here&#039;);
            _.delay(done, 30);
        });
    });

});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
